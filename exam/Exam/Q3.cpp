#include <cstdio>
#include <string>
#include <vector>

// Разработка кода, устойчивого в возникновению исключений

// Гарантии безопасности исключений
// 1. Отсутствие безопасности исключений
// 2. Минимальный уровень безопасности
// 3. Базовый уровень безопасности
// 4. Сильный (строгий) уровень безопасности
// 5. Гарантия отсутствия исключений

// 1. Худший уровень безопасности
// При выбросе исключений: неопр поведение, утечка памяти, аварийное завершение

// 2. 
// При выбросе исключений: отсутствие неопр поведения и утечек памяти
// Не сохраняются инварианты объекта: данные находятся в несоглас. сост., единственное безопасное действие - вызов деструктора

// 3.
// Сохраняются инварианты объекта: данные находятся в согласованном, м.б. даже в непредсказуемом состоянии
// Приемлемый уровень безопасности

// 4.
// Отсутсвие побочных эффектов: объекты возвращ в изнач состоянии, в котором они находились до выполнения

// 5.
// При выполнении операции исключения не выбрасываются: try...catch внутри операции
// Исключения не должен выбрасывать код вызываемый извне
// ?При выбросе исключения в деструкторе - аварийное завершение


// При исключение в конструкторе: ~полей, ~базовых классов -> деструктор самого класса вызван НЕ БУДЕТ


// RAII - "захват ресурса должен быть инициализацией объекта". 
// Пусть программе требуется какой-то ресурс (память, файл), который надо обязательно «вернуть», когда он будет уже не нужен.
// Идея состоит в том, что лучше всего запрашивать этот ресурс в конструкторе некоторого объекта, а освобождать — в деструкторе.
// Управление ресурсами с привязкой к области видимости

// Использование умных указателей и контейнеров не гарантируетбезопасного к вощникновению исключений кода
  // Можно добиться гарантии базовой или минимаольной безопасности исключений
// Строгая гарантия безопасности исключений может потребовать внесения изменений в архитектуру класса


// Как сделать класс безопасным к возникновению исключений
// 1. Внутри каждого метода выделить фрагменты, которые могут выбросить исключение
// 2. Оценить последствия исключений
// 3. Реорганизовать коф функции или метода так, чтоюы исключения не выбрасывались в процессе изменения состояния объекта
// 4. После подготовленных операций можно изменить состояние, используя операции, не выбрасывающие исключений

// noexcept

// Рекомендации по разработке Exception-Safe кода
// 1. Стремиться к сокращению размеров методов или функций (один метод - одна задача)
// 2. Использовать надежные механизмы (RAII, Smart Pointers, проверенные библиотеки)
// 3. В unit-тестах моделировать наиболее вероятные проблемные ситуации (mock)
// 4. Использование вспомогательных инструментов (детектор утечек памяти)

void Foo(std::string name, std::string surname)
{
	m_name = name;

	// ...

	m_surname = surname;
}

const int x = 10;
char* m_chars;
char* m_another_chars;

void Bar(int tt = 0)
{
	int x = 0;
	m_chars = new char[100];
	m_another_chars = new char[100];
}









// std::unique_ptr — умный указатель, владеющий динамически выделенным ресурсом.
// std::shared_ptr — умный указатель, владеющий разделяемым динамически выделенным ресурсом.
//   Несколько std::shared_ptr могут владеть одним и тем же ресурсом, и внутренний счетчик ведет их учет.
// std::weak_ptr — подобен std::shared_ptr, но не увеличивает счетчик